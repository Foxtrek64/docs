{
  "contribute/style-quick-start.html": {
    "href": "contribute/style-quick-start.html",
    "title": "Docs Style guide - Quick start | LuzFaltex Documentation",
    "keywords": "Docs style and voice quick start This quick start is a brief guide to writing technical content for publication on docs.luzfaltex.com. These guidelines apply whether you are creating new documentation or updating existing documentation. Best practices: Check the spelling and grammar in your articles, even if you have to copy and paste into Microsoft Word to check. Use a casual and friendly voice—like you're talking to another person one-on-one. Use simple sentences. Easy-to-read sentences mean the reader can quickly use the guidance you share. Use the Microsoft voice principles We aspire to follow these principles when we write technical content for docs.luzfaltex.com . We might not always get there, but we need to keep trying! Focus on the intent : Customers have a specific purpose in mind when they consult our documentation. Before you begin writing, clearly determine who the customer is and what task they are trying to do. Then, write your article to help that specific customer do that specific task. Use everyday words : Try to use natural language, the words your customers use. Be less formal but not less technical. Provide examples that explain new concepts. Write concisely : Don't waste words. Be affirmative and don't use extra words or lots of qualifiers. Keep sentences short and concise. Keep your article focused. If a task has a qualifier, put it at the beginning of the sentence or paragraph. Also, keep the number of notes to a minimum. Use a screenshot when it can save words. Make your article easy to scan : Put the most important things first. Use sections to chunk long procedures into more manageable groups of steps. (Procedures with more than 12 steps are probably too long.) Use a screenshot when it adds clarity. Show empathy : Use a supportive tone in the article, and keep disclaimers to a minimum. Honestly call out areas that will be frustrating to customers. Make sure the article focuses on what matters to customers; don't just give a technical lecture. Consider localization and machine translation Our technical articles are translated into several languages, and some are modified for particular markets or geographies. People might also use machine translation on the web to read the technical articles. So, keep the following guidelines in mind when you're writing: Make sure the article contains no grammar, spelling, or punctuation errors : This is something we should do in general. Some Markdown editors (such as MarkdownPad 2.0) have a basic spell checker, but it's a good practice to paste the rendered HTML content from the article into Word, which has a more robust spell and grammar checker. Make your sentences as short as possible : Compound sentences or chains of clauses make translation difficult. Split up sentences if you can do it without being too redundant or sounding weird. We don't want articles written in unnatural language either. Use simple and consistent sentence construction : Consistency is better for translation. Avoid parentheticals and asides, and have the subject as near the beginning of the sentence as possible. Check out a few published articles. If an article has a friendly, easy-to-read style, use it as a model. Use consistent wording and capitalization : Again, consistency is key. Do not capitalize a word if it isn't at the start of a sentence or it isn't a proper noun. Include the \"small words\" : Words that we consider small and unimportant in English because they are understood for context (such as \"a,\" \"the,\" \"that,\" and \"is\") are crucial for machine translation. Be sure to include them. Other style and voice issues to watch for Don't break up steps with commentary or asides. For steps that include code snippets, put additional information about the step into the code as comments. This reduces the amount of text that people have to read through. The key information gets copied into the code project to remind people of what the code is doing when they refer to it later. Use sentence case for all titles and headings. Use \"sign in\" and not \"log in.\" For more guidelines, see the Microsoft Writing Style Guide ."
  },
  "contribute/quick-create.html": {
    "href": "contribute/quick-create.html",
    "title": "Quickstart: Set and retrieve a secret from Azure Key Vault | Microsoft Docs | LuzFaltex Documentation",
    "keywords": "Quickstart: Set and retrieve a secret from Azure Key Vault This quickstart shows you how to store a secret in Key Vault and how to retrieve it using a Web app. To see the secret value you would have to run this on Azure. The quickstart uses Node.js and Managed service identities (MSIs). Create a Key Vault. Store a secret in the Key Vault. Retrieve a secret from Key Vault. Create an Azure Web Application. Enable managed service identities . Grant the required permissions for the web application to read data from Key vault. Before you proceed make sure that you are familiar with the basic concepts . Note To understand why the below tutorial is the best practice we need to understand a few concepts. Key Vault is a central repository to store secrets programmatically. But to do so applications / users need to first authenticate to Key Vault i.e. present a secret. To follow security best practices this first secret needs to be rotated periodically as well. But with Managed Service Identity , applications that run in Azure are given an identity which is automatically managed by Azure. This helps solve the Secret Introduction Problem where users / applications can follow best practices and not have to worry about rotating the first secret Prerequisites Node JS Visual Studio 2017 version 15.7.3 or later with the following workloads: ASP.NET and web development .NET Core cross-platform development .NET Core 2.1 SDK or later Git ( download ). An Azure subscription. If you don't have an Azure subscription, create a free account before you begin. Azure CLI version 2.0.4 or later. This is available for Windows, Mac, and Linux. Login to Azure To log in to Azure using the CLI, you can type: az login Create resource group Create a resource group with the az group create command. An Azure resource group is a logical container into which Azure resources are deployed and managed. Please select a Resource Group name and fill in the placeholder. The following example creates a resource group named in the eastus location. # To list locations: az account list-locations --output table az group create --name \"<YourResourceGroupName>\" --location \"East US\" The resource group you just created is used throughout this tutorial. Create an Azure Key Vault Next you create a Key Vault using the resource group created in the previous step. Although “ContosoKeyVault” is used as the name for the Key Vault throughout this article, you have to use a unique name. Provide the following information: Vault name - Select a Key Vault Name here . Resource group name - Select a Resource Group Name here . The location - East US . az keyvault create --name \"<YourKeyVaultName>\" --resource-group \"<YourResourceGroupName>\" --location \"East US\" At this point, your Azure account is the only one authorized to perform any operations on this new vault. Add a secret to key vault We're adding a secret to help illustrate how this works. You could be storing a SQL connection string or any other information that you need to keep securely but make available to your application. In this tutorial, the password will be called AppSecret and will store the value of MySecret in it. Type the commands below to create a secret in Key Vault called AppSecret that will store the value MySecret : az keyvault secret set --vault-name \"<YourKeyVaultName>\" --name \"AppSecret\" --value \"MySecret\" To view the value contained in the secret as plain text: az keyvault secret show --name \"AppSecret\" --vault-name \"<YourKeyVaultName>\" This command shows the secret information including the URI. After completing these steps, you should have a URI to a secret in an Azure Key Vault. Write this information down. You need it in a later step. Clone the Repo Clone the repo in order to make a local copy for you to edit the source by running the following command: git clone https://github.com/Azure-Samples/key-vault-node-quickstart.git Install dependencies Here we install the dependencies. Run the following commands: cd key-vault-node-quickstart npm install This project used 2 node modules: ms-rest-azure azure-keyvault Publish the web application to Azure Below are the few steps we need to do to publish the application to Azure. The 1st step is to create a Azure App Service Plan. You can store multiple web apps in this plan. az appservice plan create --name myAppServicePlan --resource-group myResourceGroup Next we create a web app. In the following example, replace <app_name> with a globally unique app name (valid characters are a-z, 0-9, and -). The runtime is set to NODE|6.9. To see all supported runtimes, run az webapp list-runtimes az webapp create --resource-group myResourceGroup --plan myAppServicePlan --name <app_name> --runtime \"NODE|6.9\" --deployment-local-git When the web app has been created, the Azure CLI shows output similar to the following example: { \"availabilityState\": \"Normal\", \"clientAffinityEnabled\": true, \"clientCertEnabled\": false, \"cloningInfo\": null, \"containerSize\": 0, \"dailyMemoryTimeQuota\": 0, \"defaultHostName\": \"<app_name>.azurewebsites.net\", \"enabled\": true, \"deploymentLocalGitUrl\": \"https://<username>@<app_name>.scm.azurewebsites.net/<app_name>.git\" < JSON data removed for brevity. > } Browse to your newly created web app and you should see a functioning web app. Replace <app_name> with a unique app name. http://<app name>.azurewebsites.net The above command also creates a Git-enabled app which allows you to deploy to azure from your local git. Local git is configured with url of 'https:// @<app_name>.scm.azurewebsites.net/<app_name>.git' Create a deployment user After the previous command is completed you can add add an Azure remote to your local Git repository. Replace with the URL of the Git remote that you got from Enable Git for your app. git remote add azure <url> Open and edit the solution Edit the program.cs file to run the sample with your specific key vault name: Browse to the folder key-vault-dotnet-core-quickstart. Open the key-vault-dotnet-core-quickstart.sln file in Visual Studio 2017. Open the Program.cs file and update the placeholder YourKeyVaultName with the name of your key vault that you created earlier. This solution uses AppAuthentication and KeyVault NuGet libraries. Run the app From the main menu of Visual Studio 2017, select Debug > Start without debugging. When the browser appears, go to the About page. The value for AppSecret is displayed. Publish the web application to Azure Publish this app to Azure to see it live as a web app, and to see that you can fetch the secret value: In Visual Studio, select the key-vault-dotnet-core-quickstart project. Select Publish > Start . Create a new App Service , and then select Publish . Change the app name to keyvaultdotnetcorequickstart . Select Create . Enable managed service identities Azure Key Vault provides a way to securely store credentials and other keys and secrets, but your code needs to authenticate to Azure Key Vault to retrieve them. Managed Service Identity makes this easier by giving Azure services an automatically managed identity in Azure Active Directory (Azure AD). You can use this identity to authenticate to any service that supports Azure AD authentication, including Key Vault, without having any credentials in your code. Return to the Azure CLI. Run the assign-identity command to create the identity for this application: az webapp identity assign --name \"keyvaultdotnetcorequickstart\" --resource-group \"<YourResourceGroupName>\" Note The command in this procedure is the equivalent of going to the portal and switching Managed service identity to On in the web application properties. Assign permissions to your application to read secrets from Key Vault Make a note of the output when you publish the application to Azure. It should be of the format: { \"principalId\": \"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\", \"tenantId\": \"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\", \"type\": \"SystemAssigned\" } Then, run this command by using the name of your key vault and the value of PrincipalId : az keyvault set-policy --name '<YourKeyVaultName>' --object-id <PrincipalId> --secret-permissions get Deploy the Node App to Azure and retrieve the secret value Now that everything is set. Run the following command to deploy the app to Azure git push azure master After this when you browse https://<app_name>.azurewebsites.net you can see the secret value. Make sure that you replaced the name with your vault name Now when you run the application, you should see your secret value retrieved. Next steps Azure Key Vault Home Page Azure Key Vault Documentation Azure SDK For Node Azure REST API Reference Azure Key Vault home page Azure Key Vault documentation Azure SDK For .NET Azure REST API reference"
  },
  "contribute/index.html": {
    "href": "contribute/index.html",
    "title": "LuzFaltex Docs contributor guide overview | LuzFaltex Documentation",
    "keywords": "LuzFaltex Docs contributor guide overview Welcome to the docs.luzfaltex.com (Docs) Contributor Guide! Several of our documentation sets are open source, hosted on GitHub. This streamlines and improves communication between the product engineers, the content teams, and our customers. Working in the open provides several advantages: Open source repos plan in the open to get feedback on what docs are most needed. Open source repos review in the open to publish the most helpful content on our first release. Open source repos update in the open to make it easier to continuously improve the content. The user experience on docs.luzfaltex.com integrates GitHub workflows directly to make it even easier. Start by editing the document you are viewing . Or, help by reviewing new topics , or create quality issues . Important All repositories that publish to docs.luzfaltex.com have adopted the Microsoft Open Source Code of Conduct . For more information, see the Code of Conduct FAQ or contact opencode@microsoft.com with any questions or comments. Quick edits to existing documents Quick edits streamline the process to report and fix small errors and omissions in documents. Despite all efforts, small grammar and spelling errors do make their way into our published documents. While you can create issues to report mistakes, it's faster and easier to create a pull request (PR) to fix the issue. Almost every article displays an edit button as shown in the following figure. Clicking the Edit (or equivalent localized) button takes you to the source file on GitHub. Next, click the pencil icon, shown in the following figure to edit the article. Note If the pencil icon is grayed out, you need to login to your GitHub account, or create a new account. Make your changes in the web editor. You can click the Preview changes tab to check formatting of your change. Once you have made your changes, scroll to the bottom of the page. Enter a title and description for your PR and click Propose file change as shown in the following figure: Now that you've proposed your change, you need to ask the owners of the repository to \"pull\" your changes into their repository. This is done using something called a \"pull request\". When you clicked on Propose file change in the figure above, you should have been taken to a new page that looks like the following figure: Click Create pull request , enter a title (and optionally a description) for the pull request, and then click Create pull request again. That's it! Content team members will review and merge your PR. You may get some feedback requesting changes if you made larger changes. The GitHub editing UI responds to your permissions on the repository. The preceding images are accurate for contributors that do not have write permissions to the target repository. GitHub automatically creates a fork of the target repository in your account. If you have write access to the target repository, GitHub creates a new branch in the target repo. The branch name has the form <GitHubId>-patch-n using your GitHub ID, and a numeric identifier for the patch branch. We use PRs for all changes, even for contributors that have write access. Most repositories have the master branch protected so that updates must be submitted as PRs. The in-browser editing experience is best for minor or infrequent changes. If you make large contributions, or use advanced Git features (such as branch management or advanced merge conflict resolution), you need to fork the repo and work locally . Review open PRs You can read new topics before they are published by checking the currently open PRs. Reviews follow the GitHub flow process. You can see proposed updates or new articles in public repositories. Review them and add your comments. Look at any of our docs repositories, and check the open pull requests (PRs) for areas that interest you. Community feedback on proposed updates helps the entire community. Create quality issues Our docs are a continuous work in progress. Good issues help us focus our efforts on the highest priorities for the community. The more detail you can provide, the more helpful the issue. Tell us what information you sought. Tell us the search terms you used. If you can't get started, tell us how you want to start exploring unfamiliar technology. Issues start the conversation about what's needed. The content team will respond to these issues with ideas for what we can add, and ask for your opinions. When we create a draft, we'll ask you to review the PR . Get more involved Other topics help you get started productively contributing to LuzFaltex Docs. They explain working with GitHub repositories, Markdown tools, and extensions used in the LuzFaltex Docs platform."
  },
  "contribute/how-to-write-workflows-major.html": {
    "href": "contribute/how-to-write-workflows-major.html",
    "title": "GitHub contribution workflow for major or long-running changes | LuzFaltex Documentation",
    "keywords": "GitHub contribution workflow for major or long-running changes Important All repositories that publish to docs.luzfaltex.com have adopted either the Microsoft Open Source Code of Conduct . For more information, see the Code of Conduct FAQ or contact opencode@microsoft.com with any questions or comments. Overview This workflow is suitable for a contributor who needs to make a major change or will be a frequent contributor to a repository. Frequent contributors typically have ongoing (long-running) changes, which go through multiple build/validation/staging cycles or span multiple days before pull request sign-off and merge. Examples of these types of contributions include: Making a large contribution . For instance, you might make contributions (additions, changes, or deletions) that span multiple articles and need to be committed and tested as one unit of work in a single pull request. Creating and publishing a new article , which typically requires a more robust local editor. Adding new images or updating images , which typically requires simultaneous creation of a new media subdirectory, image files, updates to image links in articles, and previewing markdown files in a local editor to test image rendering. Updating an article over a period of days before you publish . In these cases, you typically need to do regular integration of other changes that occur in the master branch. This integration is easier via Git Bash and local editing. You also run the risk of losing your edits if you do this via the GitHub UI and wait before you commit the changes. Making continual updates to the same article after a pull request has been opened (unless you are comfortable doing this via the GitHub UI). Using the GitHub UI has the potential to create multiple outstanding pull requests for the same file, which may conflict with one another. Terminology Before you start, let's review some of the Git/GitHub terms and monikers used in this workflow. Don't worry about understanding them now. Just know that you will be learning about them, and you can refer back to this section when you need to verify a definition. Name Description fork Normally used as a noun, when referring to a copy of a main GitHub repository. In practice, a fork is just another repository. But it's special in the sense that GitHub maintains a connection back to the main/parent repository. It's sometimes used as a verb, as in \"You must fork the repository first.\" remote A named connection to a remote repository, such as the \"origin\" or \"upstream\" remote. Git refers to these as remotes because they are used to reference a repository that's hosted on another computer. In this workflow, a remote is always a GitHub repository. origin The name assigned to the connection between your local repository and the repository from which it was cloned. In this workflow, origin represents the connection to your fork. It's sometimes used as a moniker for the origin repository itself, as in \"Remember to push your changes to origin.\" upstream Like the origin remote, upstream is a named connection to another repository. In this workflow, upstream represents the connection between your local repository and the main repository, from which your fork was created. It's sometimes used as a moniker for the upstream repository itself, as in \"Remember to pull the changes from upstream.\" Workflow Important If you haven't already, you must complete the steps in the Setup section. This section walks you through setting up your GitHub account, installing Git Bash and a Markdown editor, creating a fork, and setting up your local repository. If you are unfamiliar with Git and GitHub concepts such as a repository or branch, please first review Git and GitHub fundamentals . In this workflow, changes flow in a repetitive cycle. Starting from your device's local repository, they flow back up to your GitHub fork, into the main GitHub repository, and back down locally again as you incorporate changes from other contributors. Use GitHub flow Recall from Git and GitHub fundamentals that a Git repository contains a master branch, plus any additional work-in-progress branches that have not been integrated into master. Whenever you introduce a set of logically related changes, it’s a best practice to create a working branch to manage your changes through the workflow. We refer to it here as a working branch because it's a workspace to iterate/refine changes, until they can be integrated back into the master branch. Isolating related changes to a specific branch allows you to control and introduce those changes independently, targeting them to a specific release time in the publishing cycle. In reality, depending on the type of work you do, you can easily end up with several working branches in your repository. It's not uncommon to be working on multiple branches at the same time, each representing a different project. Tip Making your changes in the master branch is not a good practice. Imagine that you use the master branch to introduce a set of changes for a timed feature release. You finish the changes and are waiting to release them. Then in the interim, you have an urgent request to fix something, so you make the change to a file in the master branch and then publish the change. In this example, you inadvertently publish both the fix and the changes that you were holding for release on a specific date. Now let's create a new working branch in your local repository, to capture your proposed changes. Each git client is different, so consult the help for your preferred client. You can see an overview of the process in the GitHub Guide on GitHub flow . Pull request processing The previous section walked you through the process of submitting proposed changes, by bundling them in a new pull request (PR) that is added to the destination repository's PR queue. A pull request enables GitHub's collaboration model, by asking for the changes from your working branch to be pulled and merged into another branch. In most cases, that other branch is the default/master branch in the main repository. Validation Before your pull request can be merged into its destination branch, it might be required to pass through one or more PR validation processes. Validation processes can vary depending on the scope of proposed changes and the rules of the destination repository. After your pull request is submitted, you can expect one or more of the following to happen: Mergeability : A baseline GitHub mergeability test occurs first, to verify whether the proposed changes in your branch are in conflict with the destination branch. If the pull request indicates that this test failed, you must reconcile the content that is causing the merge conflict before processing can continue. CLA : If you are contributing to a public repository and are not a Microsoft employee, depending on the magnitude of the proposed changes, you might be asked to complete a short Contribution License Agreement (CLA) the first time you submit a pull request to that repository. After the CLA step is cleared, your pull request is processed. Labeling : Labels are automatically applied to your pull request, to indicate the state of your pull request as it passes through the validation workflow. For instance, new pull requests might automatically receive the \"do-not-merge\" label, indicating that the pull request has not yet completed the validation, review, and sign-off steps. Validation and build : Automated checks verify whether your changes pass validation tests. The validation tests might yield warnings or errors, requiring you to make changes to one or more files in your pull request before it can be merged. The validation test results are added as a comment in your pull request for your review, and they might be sent to you in e-mail. Staging : The article pages affected by your changes are automatically deployed to a staging environment for review upon successful validation and build. Preview URLs appear in a PR comment. Auto-merge : The pull request might be automatically merged, if it passes validation testing and certain criteria. In this case, you don't need to take any further action. Review and sign-off After all PR processing is completed, you should review the results (PR comments, preview URLs, etc.) to determine if additional changes to its files are required before you sign off for merging. If a PR reviewer has reviewed your pull request, they can also provide feedback via comments if there are outstanding issues/questions to be resolved prior to merge. Comment automation enables read-level users (users who don't have write permissions in a repo) to perform a write-level action, by assigning the appropriate label to a pull request. If you are working in a repository where comment automation has been implemented, use the hashtag comments listed in the following table to assign labels, change labels, or close a pull request. Microsoft employees will also be notified via e-mail for review and sign-off of public repository PRs, whenever changes are proposed to articles for which you are the author. Hashtag comment What it does Repo availability #sign-off When the author of an article types the #sign-off comment in the comment stream, the ready-to-merge label is assigned. This label lets the reviewers in the repo know when a pull request is ready for review/merge. Public and private #sign-off If a contributor who is not the listed author tries to sign off on a public pull request by using the #sign-off comment, a message is written to the pull request indicating that only the author can assign the label. Public #hold-off Authors can type #hold-off in a PR comment to remove the ready-to-merge label--in case they change their mind or make a mistake. In the private repo, this assigns the do-not-merge label. Public and private #please-close Authors can type #please-close in the comment stream to close the pull request if they decide not to have the changes merged. Public When the pull request is issue-free and signed off, your changes are merged back into the parent branch and the pull request is closed. Publishing Remember, your pull request has to be merged by a PR reviewer before the changes can be included in the next scheduled publishing run. Pull requests are normally reviewed/merged in the order of submission. If your pull request requires merging for a specific publishing run, you will need to work with your PR reviewer ahead of time to ensure that merging happens prior to publishing. After your contributions are approved and merged, the docs.microsoft.com publishing process picks them up. Depending on the team that manages the repository you are contributing to, publishing times can vary. Articles published under the following paths are normally deployed at approximately 10:30 AM and 3:30 PM Pacific Time, Monday-Friday: https://docs.microsoft.com/azure/ https://docs.microsoft.com/aspnet/ https://docs.microsoft.com/dotnet/ https://docs.microsoft.com/enterprise-mobility-security It can take up to 45 minutes for articles to appear online after publishing. After your article is published, you can verify your changes at the appropriate URL: https://docs.microsoft.com/<path-to-your-article-without-the-md-extension> . Next steps That's it! You've made a contribution to docs.luzfaltex.com content! To learn more about topics such as Markdown and Markdown extensions syntax, continue to the \"Writing essentials\" section."
  },
  "contribute/how-to-write-links.html": {
    "href": "contribute/how-to-write-links.html",
    "title": "How to use links in documentation | LuzFaltex Documentation",
    "keywords": "Using links in documentation This article describes how to use hyperlinks from pages hosted at docs.luzfaltex.com. Links are easy to add into markdown with a few varying conventions. Links point users to content in the same page, point off into other neighboring pages, or point to external sites and URLs. The docs.luzfaltex.com site backend uses Open Publishing Services (OPS) which implements DocFX Flavored Markdown (DFM). DFM is highly compatible with GitHub Flavored Markdown (GFM), and DFM adds additional functionality through Markdown extensions. Important All links must be secure ( https vs http ) whenever the target supports it (which the vast majority should). Link text The words that you include in link text should be friendly. In other words, they should be normal English words or the title of the page that you're linking to. Important Do not use \"click here.\" It's bad for SEO and doesn't adequately describe the target. Correct: For more information, see the [contributor guide index](https://github.com/LuzFaltex/docs/blob/master/docs/contribute/index.md). For more details, see the [SET TRANSACTION ISOLATION LEVEL](https://msdn.microsoft.com/library/ms173763.aspx) reference. Incorrect: For more details, see [https://msdn.microsoft.com/library/ms173763.aspx](https://msdn.microsoft.com/library/ms173763.aspx). For more information, click [here](https://github.com/LuzFaltex/docs/blob/master/docs/contribute/index.md). Links from one article to another To create an inline link from a Docs technical article to another Docs technical article within the same docset, use the following link syntax: An article in a directory links to another article in the same directory: [link text](article-name.md) An article links from a subdirectory to an article in the root directory: [link text](../article-name.md) An article in the root directory links to an article in a subdirectory: [link text](./directory/article-name.md) An article in a subdirectory links to an article in another subdirectory: [link text](../directory/article-name.md) An article linking across docsets (even if in the same repository): [link text](./directory/article-name) Important None of the above examples use the ~/ as part of the link. If you are linking to a path at the root of the repository, start with the / . Including the ~/ produces invalid links when navigating the source repositories on GitHub. Starting the path with / resolves correctly. Links to anchors You do not have to create anchors. They're automatically generated at publishing time for all H2 headings. The only thing you have to do is create links to the H2 sections. To link to a heading within the same article: [link](#the-text-of-the-H2-section-separated-by-hyphens) [Create cache](#create-cache) To link to an anchor in another article in the same subdirectory: [link text](article-name.md#anchor-name) [Configure your profile](media-services-create-account.md#configure-your-profile) To link to an anchor in another service subdirectory: [link text](../directory/article-name.md#anchor-name) [Configure your profile](../directory/media-services-create-account.md#configure-your-profile) Links from includes Because include files are located in another directory, you must use longer relative paths. To link to an article from an include file, use this format: [link text](../articles/folder/article-name.md) Links in selectors If you have selectors that are embedded in an include--as does the Azure documentation team--use the following link structure: > [AZURE.SELECTOR-LIST (Dropdown1 | Dropdown2 )] - [(Text1 | Example1 )](../articles/folder/article-name1.md) - [(Text1 | Example2 )](../articles/folder/article-name2.md) - [(Text2 | Example3 )](../articles/folder/article-name3.md) - [(Text2 | Example4 )](../articles/folder/article-name4.md) --> Reference-style links You can use reference-style links to make your source content easier to read. Reference-style links replace inline link syntax with simplified syntax that allows you to move the long URLs to the end of the article. Here's Daring Fireball 's example: Inline text: I get 10 times more traffic from [Google][1] than from [Yahoo][2] or [MSN][3]. Link references at the end of the article: <!--Reference links in article--> [1]: http://google.com/ [2]: http://search.yahoo.com/ [3]: http://search.msn.com/ Make sure that you include the space after the colon, before the link. When you link to other technical articles, if you forget to include the space, the link will be broken in the published article. Links to pages that are not part of the technical documentation set To link to a page on another LuzFaltex property (such as a pricing page, SLA page, or anything else that is not a documentation article), use an absolute URL. The goal here is that links work in GitHub and on the rendered site: [link text](https://www.luzfaltex.com/forum/thread/1-welcome/) Links to third-party sites The best user experience minimizes sending users to another site. So base any links to third-party sites, which we do sometimes need, on this info: Accountability : Link to third-party content when it's the third-party's information to share. For example, it's not LuzFaltex's place to tell people how to use Android developer tools--that is Google's story to tell. If we need to, we can explain how to use Android developer tools with Azure, but Google should tell the story of how to use their tools. PM signoff : Request that LuzFaltex sign off on third-party content. By linking to it, we are saying something about our trust in it and our obligation if people follow the instructions. Freshness reviews : Make sure that the third-party info is still current, correct, and relevant, and that the link hasn’t changed. Offsite : Make users aware that they are going to another site. If the context does not make that clear, add a qualifying phrase. For example: “Prerequisites include the Android Developer Tools, which you can download on the Android Studio site.” Next steps : It’s fine to add a link to, say, an MVP blog in a \"Next steps\" section. Again, just make sure that users understand they’ll be leaving the site. Legal : We are covered legally under Links to Third Party Sites in the Terms of Use footer on every LuzFaltex.com page. Links to MSDN or TechNet When you need to link to MSDN or TechNet, use the full link to the topic, and remove the \"en-us\" language locale from the link."
  },
  "contribute/how-to-write-docs-auth-pack.html": {
    "href": "contribute/how-to-write-docs-auth-pack.html",
    "title": "Docs Authoring Pack for VS Code | LuzFaltex Documentation",
    "keywords": "Docs Authoring Pack for VS Code The Docs Authoring Pack is a collection of VS Code extensions to aid with Markdown authoring for docs.luzfaltex.com. The pack is available in the VS Code Marketplace and contains the following extensions: markdownlint : A popular Markdown linter by David Anson to help ensure your Markdown follows best practices. Code Spell Checker : A fully offline spell checker by Street Side Software. Docs Preview : Uses the docs.luzfaltex.com CSS for more accurate Markdown preview, including custom Markdown. Docs Markdown : Provides Markdown authoring assistance for docs.luzfaltex.com content in the Open Publishing System (OPS), including basic Markdown support and support for custom Markdown syntax in OPS. The rest of this topic describes the Docs Markdown extension. Docs Article Templates : Allows users to apply Markdown skeleton content to new files. Prerequisites and assumptions To accurately insert relative links, images, and other embedded content with the Docs Markdown extension, you must have your VS Code workspace scoped to the root of your cloned Open Publishing System (OPS) repo. Some syntax supported by the extension, such as alerts and snippets, are custom Markdown for OPS, and will not render correctly unless published via OPS. How to use the Docs Markdown extension To access the Docs Markdown menu, type ALT+M . You can click or use up/down arrows to select the function you want, or type to start filtering, then hit ENTER when the function you want is highlighted in the menu. The following are available: Function Description Preview Preview the active topic in a side-by-side window using the Docs Preview extension. This option is only available if Docs Preview is installed. Bold Formats text bold . Italic Formats text italic . Code If one line or less is selected, formats text as inline code . If multiple lines are selected, formats them as a fenced code block, and allows you to optionally select a programming language supported by OPS. Alert Inserts a Note, Important, Warning, or Tip. Select Alert from the menu, then select the alert type. If you have previously selected text, it will be surrounded with the selected alert syntax. If no text is selected, a new alert will be added with placeholder text. Numbered list Inserts a new numbered list. If multiple lines are selected, each will be a list item. Note that numbered lists show in the Markdown as all 1s, but will render on docs.luzfaltex.com as sequential numbers or, for nested lists, letters. To create a nested numbered list, tab from within the parent list. Bulleted list Inserts a new bulleted list. Table Inserts a Markdown table structure. After you select the table command, specify the number of columns and rows in the format columns:rows, such as 3:4. Note that the maximum number of columns you can specify via this extension is 5, which is the recommended maximum for readability. Link to file in repo Inserts a relative link to another file in the current repo. After selecting this option, type in the command window to filter files by name, then select the file you want. If you have previously selected text, it will become the link text. Otherwise, the H1 of the target file will be used as link text. Link to web page Inserts a link to a web page. After selecting this option, paste or type the URI into the command window. https:// is required. If you have previously selected text, it will become the link text. Otherwise, the URI will be used as link text. Link to heading Links to a bookmark in the current file or another file in the repo. Bookmark in this file : Choose from a list of headings in the current file to insert a properly formatted bookmark. Bookmark in another file : First, filter by file name and select the file to link to, then choose the appropriate heading within the selected file. Image Type alternate text (required for accessibility) and select it, then call this command to filter the list of supported image files in the repo and select the one you want. If you haven't selected alt text when you call this command, you will be prompted for it before you can select an image file. Include Find a file to embed in the current file. Snippet Find a code snippet in the repo to embed in the current file. Video Add an embedded video. Template Create a new file and apply a Markdown template. See Templates , below, for more information. How to assign keyboard shortcuts Type CTRL+K then CTRL+S to open the Keyboard Shortcuts list. Search for the command, such as formatBold , for which you want to create a custom keybinding. Click the plus that appears near the command name when you mouse over the line. After a new input box is visible, type the keyboard shortcut you want to bind to that particular command. For example, to use the common shortcut for bold, type ctrl+b . It's a good idea to insert a when clause into your keybinding, so it won't be available in files other than Markdown. To do this, open keybindings.json and insert the following line below the command name (be sure to add a comma between lines): \"when\": \"editorTextFocus && editorLangId == 'markdown'\" Your completed custom keybinding should look like this in keybindings.json: // Place your key bindings in this file to overwrite the defaults [ { \"key\": \"ctrl+b\", \"command\": \"formatBold\", \"when\": \"editorTextFocus && editorLangId == 'markdown'\" } ] Save keybindings.json. See Keybindings in the VS Code docs for more information. How to show the legacy toolbar Users of the pre-release version of the extension will notice that the authoring toolbar no longer appears at the bottom of the VS Code window when the Docs Markdown Extension is installed. This is because the toolbar took up a lot of space on the VS Code status bar and did not follow best practices for extension UX, so it is deprecated in the new extension. However, you can optionally show the toolbar by updating your VS Code settings.json file as follows: In VS Code, go to File -> Preferences -> Settings ( CTRL+Comma ). Select User Settings to change the settings for all VS Code workspaces, or Workspace Settings to change them for just the current workspace. In the Default Settings pane, find Docs Authoring Extension Configuration, and select the pencil icon next to the desired setting. Next, you will be prompted to select either true or false . Once you've made your selection, VS Code will automatically add the value to the settings.json file and you will be prompted to reload the window for the changes to take effect. How to use Docs templates The Docs Article Templates extension lets writers in VS Code pull a Markdown template from a centralized store and apply it to a file. Templates can help ensure that required metadata is included in articles, that content standards are followed, and so on. Templates are managed as Markdown files in a public GitHub repository. To apply a template in VS Code If you don't have the Docs Markdown extension installed, hit F1 to open the command palette, start typing \"template\" to filter, then click Docs: Template . If you do have Docs Markdown installed, you can use either the command palette or click Alt+M to bring up the Docs Markdown QuickPick menu, then select Template from the list. Select the desired template from the list that appears. To add your GitHub ID and/or LuzFaltex alias to your VS Code settings The Templates extension supports three dynamic metadata fields: author, ms.author, and ms.date. That means that if a template creator uses these fields in the metadata header of a Markdown template, they will be auto-populated in your file when you apply the template, as follows: Metadata Value author Your GitHub ID, if specified in your VS Code settings file. ms.author Your LuzFaltex alias, if specified in your VS Code settings file. If you are not a LuzFaltex employee, leave this unspecified. ms.date The current date in the Docs-supported format, MM/DD/YYYY. Note that the date is not automatically updated if you subsequently update the file - you must update this manually to indicate the article freshness date. To set author (GitHub ID) and/or ms.author (LuzFaltex alias) In VS Code, go to File -> Preferences -> Settings ( CTRL+Comma ). Select User Settings to change the settings for all VS Code workspaces, or Workspace Settings to change them for just the current workspace. In the Default Settings pane on the left, find Docs Article Templates Extension Configuration, click the pencil icon next to the desired setting, then click Replace in Settings. The User Settings pane will open side-by-side, with a new entry at the bottom. Add your GitHub ID or LuzFaltex email alias, as appropriate, and save the file. You might need to close and restart VS Code for the changes to take effect. Now, when you apply a template that uses dynamic fields, your GitHub ID and/or LuzFaltex alias will be auto-populated in the metadata header."
  },
  "contribute/git-github-fundamentals.html": {
    "href": "contribute/git-github-fundamentals.html",
    "title": "Git and GitHub essentials for Documentation | LuzFaltex Documentation",
    "keywords": "Git and GitHub essentials for Docs Overview As a contributor to Docs content, you will interact with multiple tools and processes. You'll work in parallel with other contributors on the same project, potentially the exact same content, even at the same time. This is all enabled through Git and GitHub software. Git is an open-source version control system. It facilitates this type of project collaboration through distributed version control of files that live in repositories . In essence, Git makes it possible to integrate streams of work done by multiple contributors over time, for a given repository. GitHub is a web-based hosting service for Git repositories, such as those used to store docs.luzfaltex.com content. For any project, GitHub hosts the main repository, from which contributors can make copies for their own work. Git If you're familiar with centralized version control systems (such as Team Foundation Server, SharePoint, or Visual SourceSafe), you will notice that Git has a unique contribution workflow and terminology to support its distributed model. For instance, there is no file locking that is normally associated with check-out/check-in operations. As a matter of fact, Git is concerned about changes at an even finer level, comparing files byte by byte. Git also uses a tiered structure to store and manage content for a project: Repository : Also known as a repo , this is the highest unit of storage. A repository contains one or more branches. Branch : A unit of storage that contains the files and folders that make up a project's content set. Branches separate streams of work (typically referred to as versions). Contributions are always made and scoped to a specific branch. All repositories contain a default branch (typically named \"master\") and one or more branches that are destined to be merged back into the master branch. The master branch serves as the current version and \"single source of truth\" for the project. It's the parent from which all other branches in the repository are created. Contributors interact with Git to update and manipulate repositories at both the local and GitHub levels: Locally through tools such as the Git Bash console, which supports Git commands for managing local repositories and communicating with GitHub repositories Via www.github.com , which integrates Git to manage the reconciliation of contributions that flow back into the main repository GitHub Note Although Docs guidance is based on using GitHub, some teams use Visual Studio Team Services to host Git repositories. The Visual Studio Team Explorer client provides a GUI for interacting with Team Services repositories, as an alternative to using Git commands through a command line. Also, many of the following guidelines were developed as best practices from years of experience in hosting Azure service content in GitHub. They might be required in some Docs repositories. All workflows begin and end at the GitHub level, where the main repository for any Docs project is stored. The copies that contributors create for their own use are distributed across multiple computers. These copies are eventually reconciled back into the project's main GitHub repository. Directory organization As mentioned earlier, a project's default/master branch serves as the current version of content for the project. The content in the master branch--and branches created from it--is loosely aligned with the organization of the articles on the corresponding Docs pages. Subdirectories are used for separation of like content (such as services), media content (such as image files), and \"include\" files (which enable reuse of content). Within the root of this directory, you can find general articles that relate to the overall service or product. And typically, you can then find another series of subdirectories that match the features/services or common scenarios. Media subdirectory Each article directory contains a /media subdirectory for corresponding media files. Media files contain images used by articles that have image references. Includes subdirectory Whenever we have reusable content that is shared across two or more articles, it is placed in an /includes subdirectory off the main articles directory. In a Markdown file that uses the include file, a corresponding \"include\" Markdown extension is placed in the location where the include file needs to be referenced. See How to use Markdown: Includes for additional guidance. Markdown file template For convenience, the root directory of each repository typically contains a Markdown template file named template.md . You can use this template file as a \"starter file\" if you need to create a new article for submission to the repository. The file contains: A metadata header at the top of the file, delineated by two, 3-hyphen lines. It contains the various tags used for tracking information related to the article. Article metadata enables certain functionality, such as author attribution, contributor attribution, breadcrumbs, and article descriptions. It also includes SEO optimizations and reporting processes that LuzFaltex uses to evaluate the performance of the content. So the metadata is important! A metadata section that describes the various metadata tags and values. If you're unsure of the values to use for the metadata section, you can leave them blank or comment them with a leading hashtag (#), and they will be reviewed/completed by the pull request reviewer for the repository. Various examples of using Markdown to format the elements of an article. General instructions on the use of Markdown extensions , which you can use for various types of alerts. Examples of embedding video by using an iframe. General instructions on the use of docs.luzfaltex.com extensions , which you can use for special controls such as buttons and selectors. Pull requests A pull request provides a convenient way for a contributor to propose a set of changes that will be applied to the default branch. The changes (also known as commits ) are stored in a contributor's branch, so GitHub can first model the impact of merging them into the default branch. A pull request also serves as a mechanism to provide the contributor with feedback from a build/validation process, the pull request reviewer, to resolve potential issues or questions before the changes are merged into the default branch. There are two ways to contribute by pull request, depending on the size of changes that you want to propose. We will cover this in detail later, in the GitHub workflow section of this guide."
  },
  "contribute/get-started-setup-tools.html": {
    "href": "contribute/get-started-setup-tools.html",
    "title": "Install content authoring tools | LuzFaltex Documentation",
    "keywords": "Install content authoring tools This article describes the steps to interactively install Git client tools and Visual Studio Code. Install Git Install Visual Studio Code Install Docs Authoring Pack Important If you're making only minor changes to an article, you do not need to complete the steps in this article and can continue directly to the quick changes workflow . Major contributors are encouraged to complete these steps, which enable you to use the major/long-running changes workflow . Even if you have write permissions in the main repository, we highly recommend (and this guide assumes) that you fork and clone the repository , so that you have read/write permissions to store your proposed changes in your fork. Install Git client tools Install the latest version of Software Freedom Conservancy's Git client tools for your platform. Git for Windows . This install includes the Git version control system and Git Bash, the command-line app that you use to interact with your local Git repository. Git for Mac is provided as part of the Xcode Command Line Tools. Simply run git from the command line. You will be prompted to install the command line tools if needed. You can also download Git for Mac from the Software Freedom Conservancy. Git for Linux and Unix If you prefer a graphical user interface (GUI) over a command-line interface (CLI), see Software Freedom Conservancy's available GUI Clients page , GitHub's GitHub Desktop , or Visual Studio Code for some popular options. Follow the instructions for your chosen client for installation and configuration. In the next article, you will Set up a local Git repository . Additional Git resources are available here: Git terminology | Git basics | Learning Git and GitHub Understand Markdown editors Markdown is a lightweight markup language that is both easy to read and easy to learn. Therefore, it has rapidly become an industry standard. To write articles in Markdown, we recommend that you first download and install a Markdown editor. Visual Studio Code is the preferred tool for editing Markdown at LuzFaltex. Atom is another popular tool for editing Markdown. Markdown text is saved into files with .md extension. Additional details on how to write with Markdown, including Markdown basics and the features supported by OPS custom Markdown extensions, are covered later in the How to use Markdown article. Visual Studio Code Visual Studio Code , also known as VS Code, is a lightweight editor that works on Windows, Linux, and Mac. It includes git integration, and support for extensions. Download and install VS Code . The VS Code home page should detect your operating system correctly. Windows Mac Linux Tip To launch VS Code and open the current folder, run the command code . in the command line or bash shell. If the current folder is part of a local git repo, the github integration appears in Visual Studio Code automatically. Docs Authoring Pack Install the Docs Authoring Pack for Visual Studio Code. This set of extensions includes basic authoring assistance for help when writing Markdown, and a preview feature, so that you can see what the Markdown looks like in the style of the docs.microsoft.com site. Visit this marketplace page and select Install , or search for docsmsft.docs-authoring-pack in your extensions list in the VS Code window. The Docs Authoring Pack is accessible by pressing Alt+M inside of VS Code. The toolbar is hidden by default but can be shown. Edit the VS Code settings (Control+comma) and adding user setting \"markdown.showToolbar\": true to show the toolbar. For more information, see the Docs Authoring Pack page. Next steps Now you are ready to Set up a local Git repository ."
  },
  "contribute/get-started-setup-local.html": {
    "href": "contribute/get-started-setup-local.html",
    "title": "Set up Git repository locally | LuzFaltex Documentation",
    "keywords": "Set up Git repository locally for documentation This article describes the steps to set up a git repository on your local machine, with the intent to contribute to LuzFaltex documentation. Contributors may use a locally cloned repository to add new articles, do major edits on existing articles, or change artwork. You run these one-time setup activities to get started contributing: Determine the appropriate repository Fork the repository to your GitHub account Choose a local folder for the cloned files Clone the repository to your local machine Configure the upstream remote value Important If you're making only minor changes to an article, you do not need to complete the steps in this article. You can continue directly to the quick changes workflow . Overview To contribute to LuzFaltex's documentation site, you can make and edit Markdown files locally by cloning the corresponding documentation repository. LuzFaltex requires you to fork the appropriate repository into your own github account, so that you have read/write permissions there to store your proposed changes. Then you use pull requests to merge changes into the read-only central shared repository. If you're new to GitHub, watch the following video from Microsoft for a conceptual overview of the forking and cloning process: Fork the repository Using the appropriate repository, create a fork of the repository into your own GitHub account by using the GitHub website. A personal fork is required since all main documentation repositories provide read-only access. To make changes, you must submit a pull request from your fork into the main repository. To facilitate this process, you first need your own copy of the repository, in which you have write access. A GitHub fork serves that purpose. Go to the main repository's GitHub page and click the Fork button on the upper right. If you are prompted, select your GitHub account tile as the destination where the fork should be created. This prompt creates a copy of the repository within your GitHub account, known as a fork. Choose a local folder Make a local folder to hold a copy of the repository locally. Some of the repositories can be large; up to 5 GB for azure-docs for example. Choose a location with available disk space. Choose a folder name should be easy for you to remember and type. For example, consider a root folder C:\\docs\\ or make a folder in your user profile directory ~/Documents/docs/ Important Avoid choosing a local folder path that is nested inside of another git repository folder location. While it is acceptable to store the git cloned folders adjacent to each other, nesting git folders inside one another causes errors for the file tracking. Launch Git Bash The default location that Git Bash starts in is typically the home directory (~) or /c/users/<Windows-user-account>/ on Windows OS. To determine the current directory, type pwd at the $ prompt. Change directory (cd) into the folder that you created for hosting the repository locally. Note that Git Bash uses the Linux convention of forward-slashes instead of back-slashes for folder paths. For example, cd /c/docs/ or cd ~/Documents/docs/ Create a local clone Using Git Bash, prepare to run the clone command to pull a copy of a repository (your fork) down to your device on the current directory. Authenticate by using Git Credential Manager If you installed the latest version of Git for Windows and accepted the default installation, Git Credential Manager is enabled by default. Git Credential Manager makes authentication much easier, because you don't need to recall your personal access token when re-establishing authenticated connections and remotes with GitHub. Run the clone command, by providing the repository name. Cloning downloads (clone) the forked repository on your local computer. Tip You can get your fork's GitHub URL for the clone command from the Clone or download button in the GitHub UI: Be sure to specify the path to your fork during the cloning process, not the main repository from which you created the fork. Otherwise, you cannot contribute changes. Your fork is referenced through your personal GitHub user account, such as github.com/<github-username>/<repo> . git clone https://github.com/<github-username>/<repo>.git Your clone command should look similar to this example: git clone https://github.com/smithj/azure-docs.git When you're prompted, enter your GitHub credentials. When you're prompted, enter your two-factor authentication code. Note Your credentials will be saved and used to authenticate future GitHub requests. You only need to do this authentication once per computer. The clone command runs and downloads a copy of the repository files from your fork into a new folder on the local disk. A new folder is made within the current folder. It may take a few minutes, depending on the repository size. You can explore the folder to see the structure once it is finished. Configure remote upstream After cloning the repository, set up a read-only remote connection to the main repository named upstream . You use the upstream URL to keep your local repository in sync with the latest changes made by others. The git remote command is used to set the configuration value. You use the fetch command to refresh the branch info from the upstream repository. If you're using Git Credential Manager , use the following commands. Replace the <repo> and <organization> placeholders. cd <repo> git remote add upstream https://github.com/<organization>/<repo>.git git fetch upstream View the configured values and confirm the URLs are correct. Ensure the origin URLs point to your personal fork. Ensure the upstream URLs point to the main repository, such as LuzFaltexDocs or Azure. git remote -v Example remote output is shown. A fictitious git account named MyGitAccount is configured with a personal access token to access the repo azure-docs: origin https://github.com/MyGitAccount/azure-docs.git (fetch) origin https://github.com/MyGitAccount/azure-docs.git(push) upstream https://github.com/LuzFaltexDocs/azure-docs.git (fetch) upstream https://github.com/LuzFaltexDocs/azure-docs.git (push) If you made a mistake, you can remove the remote value. To remove the upstream value, run the command git remote remove upstream . Next steps To learn more about adding and updating content, continue to the GitHub contribution workflow ."
  },
  "contribute/get-started-setup-github.html": {
    "href": "contribute/get-started-setup-github.html",
    "title": "GitHub account setup steps | LuzFaltex Documentation",
    "keywords": "GitHub account setup Set up your GitHub account To contribute to Docs technical content, you need to set up your own GitHub account. The good news is, you have to do most steps only one time. 1. Create a GitHub account and set up your profile If you don't already have a GitHub account, create one . Identify any affiliations in your GitHub profile. Note LuzFaltex employees participating in Open Source projects always identify themselves as such their in GitHub profiles. Community contributors should ensure that their profile does not incorrectly imply an employment relationship. Next steps Continue to the Tool installations article to install Git Bash, a Markdown editor, and more."
  },
  "contribute/additional-resources.html": {
    "href": "contribute/additional-resources.html",
    "title": "Additional Git and Github resources | LuzFaltex Documentation",
    "keywords": "Additional Git and Github resources If you are unfamiliar with Git or GitHub, these resources can help you learn, be productive, or answer questions. Git source control resources Git basics : This has a basic overview of how git works. Pro Git e-book (web) : This is a thorough git reference, in HTML format. Pro Git e-book (PDF) : Same as the preceding link, in PDF form. Learn Git course from Codecademy : Git tutorial from Codeacademy. Try Git course from Code School : Git tutorial from Code School GitHub resources 15-minute interactive primer : This is an online git tutorial. It exposes you to the basics of git. Cheat sheets : A quick reference to common GitHub commands and workflows. GitHub Guides : The home of GitHub documentation. GitHub learning resources : Other useful GitHub resources. GitHub training services : A listing of tutorials and training offerings from GitHub. Glossary : A handy glossary of git and GitHub terms."
  },
  "api/index.html": {
    "href": "api/index.html",
    "title": "PLACEHOLDER | LuzFaltex Documentation",
    "keywords": "PLACEHOLDER TODO: Add .NET projects to the src folder and run docfx to generate REAL API Documentation !"
  },
  "index.html": {
    "href": "index.html",
    "title": "LuzFaltex Docs Home | LuzFaltex Documentation",
    "keywords": "This is the HOMEPAGE . Refer to Markdown for how to write markdown files. Quick Start Notes: Add images to the images folder if the file is referencing an image."
  },
  "contribute/includes/contribute-how-to-write-workflows-pull-request-processing.html": {
    "href": "contribute/includes/contribute-how-to-write-workflows-pull-request-processing.html",
    "title": "Pull request processing | LuzFaltex Documentation",
    "keywords": "Pull request processing The previous section walked you through the process of submitting proposed changes, by bundling them in a new pull request (PR) that is added to the destination repository's PR queue. A pull request enables GitHub's collaboration model, by asking for the changes from your working branch to be pulled and merged into another branch. In most cases, that other branch is the default/master branch in the main repository. Validation Before your pull request can be merged into its destination branch, it might be required to pass through one or more PR validation processes. Validation processes can vary depending on the scope of proposed changes and the rules of the destination repository. After your pull request is submitted, you can expect one or more of the following to happen: Mergeability : A baseline GitHub mergeability test occurs first, to verify whether the proposed changes in your branch are in conflict with the destination branch. If the pull request indicates that this test failed, you must reconcile the content that is causing the merge conflict before processing can continue. CLA : If you are contributing to a public repository and are not a Microsoft employee, depending on the magnitude of the proposed changes, you might be asked to complete a short Contribution License Agreement (CLA) the first time you submit a pull request to that repository. After the CLA step is cleared, your pull request is processed. Labeling : Labels are automatically applied to your pull request, to indicate the state of your pull request as it passes through the validation workflow. For instance, new pull requests might automatically receive the \"do-not-merge\" label, indicating that the pull request has not yet completed the validation, review, and sign-off steps. Validation and build : Automated checks verify whether your changes pass validation tests. The validation tests might yield warnings or errors, requiring you to make changes to one or more files in your pull request before it can be merged. The validation test results are added as a comment in your pull request for your review, and they might be sent to you in e-mail. Staging : The article pages affected by your changes are automatically deployed to a staging environment for review upon successful validation and build. Preview URLs appear in a PR comment. Auto-merge : The pull request might be automatically merged, if it passes validation testing and certain criteria. In this case, you don't need to take any further action. Review and sign-off After all PR processing is completed, you should review the results (PR comments, preview URLs, etc.) to determine if additional changes to its files are required before you sign off for merging. If a PR reviewer has reviewed your pull request, they can also provide feedback via comments if there are outstanding issues/questions to be resolved prior to merge. Comment automation enables read-level users (users who don't have write permissions in a repo) to perform a write-level action, by assigning the appropriate label to a pull request. If you are working in a repository where comment automation has been implemented, use the hashtag comments listed in the following table to assign labels, change labels, or close a pull request. Microsoft employees will also be notified via e-mail for review and sign-off of public repository PRs, whenever changes are proposed to articles for which you are the author. Hashtag comment What it does Repo availability #sign-off When the author of an article types the #sign-off comment in the comment stream, the ready-to-merge label is assigned. This label lets the reviewers in the repo know when a pull request is ready for review/merge. Public and private #sign-off If a contributor who is not the listed author tries to sign off on a public pull request by using the #sign-off comment, a message is written to the pull request indicating that only the author can assign the label. Public #hold-off Authors can type #hold-off in a PR comment to remove the ready-to-merge label--in case they change their mind or make a mistake. In the private repo, this assigns the do-not-merge label. Public and private #please-close Authors can type #please-close in the comment stream to close the pull request if they decide not to have the changes merged. Public When the pull request is issue-free and signed off, your changes are merged back into the parent branch and the pull request is closed. Publishing Remember, your pull request has to be merged by a PR reviewer before the changes can be included in the next scheduled publishing run. Pull requests are normally reviewed/merged in the order of submission. If your pull request requires merging for a specific publishing run, you will need to work with your PR reviewer ahead of time to ensure that merging happens prior to publishing. After your contributions are approved and merged, the docs.microsoft.com publishing process picks them up. Depending on the team that manages the repository you are contributing to, publishing times can vary. Articles published under the following paths are normally deployed at approximately 10:30 AM and 3:30 PM Pacific Time, Monday-Friday: https://docs.microsoft.com/azure/ https://docs.microsoft.com/aspnet/ https://docs.microsoft.com/dotnet/ https://docs.microsoft.com/enterprise-mobility-security It can take up to 45 minutes for articles to appear online after publishing. After your article is published, you can verify your changes at the appropriate URL: https://docs.microsoft.com/<path-to-your-article-without-the-md-extension> ."
  },
  "contribute/includes/contribute-how-to-write-workflows-major-change-definition.html": {
    "href": "contribute/includes/contribute-how-to-write-workflows-major-change-definition.html",
    "title": "| LuzFaltex Documentation",
    "keywords": "Making a large contribution . For instance, you might make contributions (additions, changes, or deletions) that span multiple articles and need to be committed and tested as one unit of work in a single pull request. Creating and publishing a new article , which typically requires a more robust local editor. Adding new images or updating images , which typically requires simultaneous creation of a new media subdirectory, image files, updates to image links in articles, and previewing markdown files in a local editor to test image rendering. Updating an article over a period of days before you publish . In these cases, you typically need to do regular integration of other changes that occur in the master branch. This integration is easier via Git Bash and local editing. You also run the risk of losing your edits if you do this via the GitHub UI and wait before you commit the changes. Making continual updates to the same article after a pull request has been opened (unless you are comfortable doing this via the GitHub UI). Using the GitHub UI has the potential to create multiple outstanding pull requests for the same file, which may conflict with one another."
  },
  "contribute/includes/contribute-how-to-pull-requests-apex-automation.html": {
    "href": "contribute/includes/contribute-how-to-pull-requests-apex-automation.html",
    "title": "| LuzFaltex Documentation",
    "keywords": "Comment automation enables read-level users (users who don't have write permissions in a repo) to perform a write-level action, by assigning the appropriate label to a pull request. If you are working in a repository where comment automation has been implemented, use the hashtag comments listed in the following table to assign labels, change labels, or close a pull request. Microsoft employees will also be notified via e-mail for review and sign-off of public repository PRs, whenever changes are proposed to articles for which you are the author. Hashtag comment What it does Repo availability #sign-off When the author of an article types the #sign-off comment in the comment stream, the ready-to-merge label is assigned. This label lets the reviewers in the repo know when a pull request is ready for review/merge. Public and private #sign-off If a contributor who is not the listed author tries to sign off on a public pull request by using the #sign-off comment, a message is written to the pull request indicating that only the author can assign the label. Public #hold-off Authors can type #hold-off in a PR comment to remove the ready-to-merge label--in case they change their mind or make a mistake. In the private repo, this assigns the do-not-merge label. Public and private #please-close Authors can type #please-close in the comment stream to close the pull request if they decide not to have the changes merged. Public"
  },
  "contribute/validation-reference/markdown-headings.html": {
    "href": "contribute/validation-reference/markdown-headings.html",
    "title": "Markdown Headings | LuzFaltex Documentation",
    "keywords": "Markdown headings The following validation requirements apply to headings in OPS Markdown files. H1 H1 refers to the first heading in a Markdown file. When published to docs.microsoft.com, the H1 shows at the top of the page in a large font. An H1 is created by beginning a line with a single hash ( # ) followed by a space, then the heading text. For example, the H1 of this article is: # Markdown headings The following rules apply to H1 headings: An H1 must be present in the file. There can only be one H1. The H1 must have content. # This is not allowed. There must be a space between the # and the H1 content. An H1 with no space doesn't render as a heading on the published page. #This looks bad on the site. The H1 must be the first content in the file after the YML metadata header. No content, such as text or images, is allowed between the end of the YML header and the H1. --- ... YML would go here --- ![cheerful image](not-allowed.jpg) # This cheer is not allowed The HTML element for first-level headings, <h1> , should not be used. Use the Markdown syntax ( # ). The H1 should be no more than 100 characters long. This is a style guideline. H2 - H6 H2 ( ## ) through H6 ( ###### ) are allowed in OPS. Use the Markdown headers, not the HTML ( <h2> - <h6> ), to create headings."
  },
  "contribute/validation-reference/locale-specific-links.html": {
    "href": "contribute/validation-reference/locale-specific-links.html",
    "title": "Locale-specific links | LuzFaltex Documentation",
    "keywords": "Locale-specific links Locale codes, such as en-us , should not be included in links to certain Microsoft sites. If you include a locale code in a link in English content, it will also be included in localized links, which leads to a bad localized experience. For example, if a link in German localized content includes en-us , German customers will find themselves linking to the English article, even if a German version is available. Remove locale codes from links to Microsoft sites. The following is an example. Before: https://docs.microsoft.com/en-us/vsts/load-test/app-service-web-app-performance-test After: https://docs.microsoft.com/vsts/load-test/app-service-web-app-performance-test The following sites are in scope for this validation: azure.microsoft.com docs.microsoft.com msdn.microsoft.com technet.microsoft.com"
  },
  "contribute/validation-reference/index.html": {
    "href": "contribute/validation-reference/index.html",
    "title": "Docs PR validation service | LuzFaltex Documentation",
    "keywords": "Docs PR validation service The Docs PR validation service is a GitHub app that runs validation rules on the files in a PR. When the validation service is enabled on a repo, you'll see the following behavior: You submit a PR. In the GitHub comment that indicates the status of your PR, you'll see the status of \"checks\" enabled on the repo. Note that in this example, there are two checks enabled, \"Commit Validation\" and \"OpenPublishing.Build\": Build can pass even if commit validation fails. Click Details for more information. On the Details page, you'll see all the validation checks that failed, with information about how to fix the issues: See the left-hand TOC of this article for the list of validations currently in the service."
  },
  "contribute/how-to-write-use-markdown.html": {
    "href": "contribute/how-to-write-use-markdown.html",
    "title": "How to use Markdown for writing Docs | LuzFaltex Documentation",
    "keywords": "How to use Markdown for writing Docs Docs.luzfaltex.com articles are written in a lightweight markup language called Markdown , which is both easy to read and easy to learn. Because of this, it has quickly become an industry standard. Because Docs content is stored in GitHub, it can use a superset of Markdown called GitHub Flavored Markdown (GFM) , which provides additional functionality for common formatting needs. Additionally, Open Publishing Services (OPS) implements Markdig Markdown Parser. Markdig is highly compatible with GitHub Flavored Markdown (GFM), adding functionality to enable Docs-specific features. Markdig is a fast, powerful, CommonMark compliant, extensible Markdown processor for .NET. https://github.com/lunet-io/markdig Better community support Better standards support Markdown basics Headings To create a heading, you use a hash mark (#), as follows: # This is heading 1 ## This is heading 2 ### This is heading 3 #### This is heading 4 Bold and italic text To format text as bold , you enclose it in two asterisks: This text is **bold**. To format text as italic , you enclose it in a single asterisk: This text is *italic*. To format text as both bold and italic , you enclose it in three asterisks: This is text is both ***bold and italic***. Lists Unordered list To format an unordered/bulleted list, you can use either asterisks or dashes. For example, the following Markdown: - List item 1 - List item 2 - List item 3 will be rendered as: List item 1 List item 2 List item 3 To nest a list within another list, indent the child list items. For example, the following Markdown: - List item 1 - List item A - List item B - List item 2 will be rendered as: List item 1 List item A List item B List item 2 Ordered list To format an ordered/stepwise list, you use corresponding numbers. For example, the following Markdown: 1. First instruction 2. Second instruction 3. Third instruction will be rendered as: First instruction Second instruction Third instruction To nest a list within another list, indent the child list items. For example, the following Markdown: 1. First instruction 1. Sub-instruction 2. Sub-instruction 2. Second instruction will be rendered as: First instruction Sub-instruction Sub-instruction Second instruction Tables Tables are not part of the core Markdown specification, but GFM supports them. You can create tables by using the pipe (|) and hyphen (-) characters. Hyphens create each column's header, while pipes separate each column. Include a blank line before your table so it's rendered correctly. For example, the following Markdown: | Fun | With | Tables | | :------------------- | -------------------: |:---------------:| | left-aligned column | right-aligned column | centered column | | $100 | $100 | $100 | | $10 | $10 | $10 | | $1 | $1 | $1 | will be rendered as: Fun With Tables left-aligned column right-aligned column centered column $100 $100 $100 $10 $10 $10 $1 $1 $1 For more information on creating tables, see: The Markdig table wrapping feature , which can help with formatting of wide tables GitHub's Organizing information with tables The Markdown Tables Generator web app Adam Pritchard's Markdown Cheatsheet Michel Fortin's Markdown Extra Convert HTML tables to Markdown Links The Markdown syntax for an inline link consists of the [link text] portion, which is the text that will be hyperlinked, followed by the (file-name.md) portion, which is the URL or file name that's being linked to: [link text](file-name.md) For more information on linking, see: The Markdown syntax guide for details on Markdown's base linking support. The Links section of this guide for details on additional linking syntax that Markdig provides. Code snippets Markdown supports the placement of code snippets both inline in a sentence and as a separate \"fenced\" block between sentences. For details, see: Markdown's native support for code blocks GFM support for code fencing and syntax highlighting Fenced code blocks are an easy way to enable syntax highlighting for your code snippets. The general format for fenced code blocks is: ```alias ... your code goes in here ... ``` The alias after the initial three backtick (`) characters defines the syntax highlighting to be used. The following is a list of commonly used programming languages in Docs content and the matching label: These languages have friendly name support and most have language highlighting. Name Markdown Label .NET Console dotnetcli ASP.NET (C#) aspx-csharp ASP.NET (VB) aspx-vb AzCopy azcopy Azure CLI azurecli Azure PowerShell azurepowershell C++ cpp C++/CX cppcx C++/WinRT cppwinrt C# csharp CSHTML cshtml DAX dax F# fsharp Go go HTML html HTTP http Java java JavaScript javascript JSON json Markdown md NodeJS nodejs Objective-C objc OData odata PHP php Power Apps Formula powerappsfl PowerShell powershell Python python Q# qsharp Ruby ruby SQL sql Swift swift TypeScript typescript VB vb VSTS CLI vstscli XAML xaml XML xml Example: C# Markdown ```csharp // Hello1.cs public class Hello1 { public static void Main() { System.Console.WriteLine(\"Hello, World!\"); } } ``` Render // Hello1.cs public class Hello1 { public static void Main() { System.Console.WriteLine(\"Hello, World!\"); } } Example: SQL Markdown ```sql CREATE TABLE T1 ( c1 int PRIMARY KEY, c2 varchar(50) SPARSE NULL ); ``` Render CREATE TABLE T1 ( c1 int PRIMARY KEY, c2 varchar(50) SPARSE NULL ); OPS custom Markdown extensions Note Open Publishing Services (OPS) implements a Markdig Parser for Markdown, which is highly compatible with GitHub Flavored Markdown (GFM). Markdig adds some functionality through Markdown extensions. As such, selected articles from the full OPS Authoring Guide are included in this guide for reference. (For example, see \"Markdig and Markdown extensions\" and \"Code snippets\" in the table of contents.) Docs articles use GFM for most article formatting, such as paragraphs, links, lists, and headings. For richer formatting, articles can use Markdig features such as: Note blocks Includes Selectors Embedded videos Code snippets/samples For the complete list, refer to \"Markdig and Markdown extensions\" and \"Code snippets\" in the table of contents. Note blocks You can choose from four types of note blocks to draw attention to specific content: NOTE WARNING TIP IMPORTANT In general, note blocks should be used sparingly because they can be disruptive. Although they also support code blocks, images, lists, and links, try to keep your note blocks simple and straightforward. Includes When you have reusable text or image files that need to be included in article files, you can use a reference to the \"include\" file via the Markdig file include feature. This feature instructs OPS to include the file in your article file at build time, making it part of your published article. Three types of includes are available to help you reuse content: Inline: Reuse a common text snippet inline with within another sentence. Block: Reuse an entire Markdown file as a block, nested within a section of an article. Image: This is how standard image inclusion is implemented in Docs. An inline or block include is just a simple Markdown (.md) file. It can contain any valid Markdown. All include Markdown files should be placed in a common /includes subdirectory , in the root of the repository. When the article is published, the included file is seamlessly integrated into it. Here are requirements and considerations for includes: Use includes whenever you need the same text to appear in multiple articles. Use block includes for significant amounts of content--a paragraph or two, a shared procedure, or a shared section. Do not use them for anything smaller than a sentence. Includes won't be rendered in the GitHub rendered view of your article, because they rely on Markdig extensions. They'll be rendered only after publication. Ensure that all the text in an include is written in complete sentences or phrases that do not depend on preceding text or following text in the article that references the include. Ignoring this guidance creates an untranslatable string in the article that breaks the localized experience. Don't embed includes within other includes. They are not supported. Place media files in a media folder that's specific to the include subdirectory--for instance, the <repo> /includes/media folder. The media directory should not contain any images in its root. If the include does not have images, a corresponding media directory is not required. As with regular articles, don't share media between include files. Use a separate file with a unique name for each include and article. Store the media file in the media folder that's associated with the include. Don't use an include as the only content of an article. Includes are meant to be supplemental to the content in the rest of the article. Selectors Use selectors in technical articles when you author multiple flavors of the same article, to address differences in implementation across technologies or platforms. This is typically most applicable to our mobile platform content for developers. There are currently two different types of selectors in Markdig, a single selector and a multi-selector. Because the same selector Markdown goes in each article in the selection, we recommend placing the selector for your article in an include. Then you can reference that include in all your articles that use the same selector. Code snippets Markdig supports advanced inclusion of code in an article, via its code snippet extension. It provides advanced rendering that builds on GFM features such as programming language selection and syntax coloring, plus nice features such as: Inclusion of centralized code samples/snippets from an external repository. Tabbed UI to show multiple versions of code samples in different languages. Gotchas and troubleshooting Alt text Alt text that contains underscores won't be rendered properly. For example, instead of using this: ![ADextension_2FA_Configure_Step4] (./media/bogusfilename/ADextension_2FA_Configure_Step4.PNG) Escape the underscores like this: ![ADextension\\_2FA\\_Configure\\_Step4] (./media/bogusfilename/ADextension_2FA_Configure_Step4.PNG) Apostrophes and quotation marks If you copy from Word into a Markdown editor, the text might contain \"smart\" (curly) apostrophes or quotation marks. These need to be encoded or changed to basic apostrophes or quotation marks. Otherwise, you end up with things like this when the file is published: Itâ€™s Here are the encodings for the \"smart\" versions of these punctuation marks: Left (opening) quotation mark: &#8220; Right (closing) quotation mark: &#8221; Right (closing) single quotation mark or apostrophe: &#8217; Left (opening) single quotation mark (rarely used): &#8216; Angle brackets If you use angle brackets in text (not code) in your file--for example, to denote a placeholder--you need to manually encode the angle brackets. Otherwise, Markdown thinks that they're intended to be an HTML tag. For example, encode <script name> as &lt;script name&gt; See also Markdown resources Introduction to Markdown Docs Markdown cheat sheet GitHub's Markdown Basics"
  },
  "articles/intro.html": {
    "href": "articles/intro.html",
    "title": "Add your introductions here! | LuzFaltex Documentation",
    "keywords": "Add your introductions here!"
  }
}